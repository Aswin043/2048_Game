/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package twentyfortyeight;

import processing.core.PApplet;
import processing.core.PConstants;
import java.util.ArrayList;
import java.util.Random;

public class Game2048 extends PApplet {
    private int gridSize;
    private int cellSize;
    private int[][] grid;
    private ArrayList<Block> blocks;
    private Random random;
    private float startTime;
    private boolean gameOver;
    private static final int DEFAULT_SIZE = 4;
    private static final int WINDOW_SIZE = 600;
    private static final int CELL_PADDING = 10;
    private static final int[] COLORS = {
        0xEEE4DA, 0xEDE0C8, 0xF2B179, 0xF59563,
        0xF67C5F, 0xF65E3B, 0xEDCF72, 0xEDCC61,
        0xEDC850, 0xEDC53F, 0xEDC22E
    };

    public static void main(String[] args) {
        int size = DEFAULT_SIZE;
        if (args.length > 0) {
            try {
                size = Integer.parseInt(args[0]);
                if (size < 2) size = DEFAULT_SIZE;
            } catch (NumberFormatException e) {
                size = DEFAULT_SIZE;
            }
        }
        String[] processingArgs = {"twentyfortyeight.Game2048"};
        PApplet.main(processingArgs);
    }

    public void settings() {
        size(WINDOW_SIZE, WINDOW_SIZE);
    }

    public void setup() {
        gridSize = DEFAULT_SIZE;
        if (args != null && args.length > 0) {
            try {
                gridSize = Integer.parseInt(args[0]);
                if (gridSize < 2) gridSize = DEFAULT_SIZE;
            } catch (NumberFormatException e) {
                gridSize = DEFAULT_SIZE;
            }
        }
        cellSize = (WINDOW_SIZE - (gridSize + 1) * CELL_PADDING) / gridSize;
        grid = new int[gridSize][gridSize];
        blocks = new ArrayList<>();
        random = new Random();
        startTime = millis();
        gameOver = false;
        
        // Initialize with 2 random blocks
        addRandomBlock();
        addRandomBlock();
    }

    public void draw() {
        background(187, 173, 160);
        
        // Draw grid
        for (int i = 0; i < gridSize; i++) {
            for (int j = 0; j < gridSize; j++) {
                float x = CELL_PADDING + j * (cellSize + CELL_PADDING);
                float y = CELL_PADDING + i * (cellSize + CELL_PADDING);
                fill(205, 193, 180);
                rect(x, y, cellSize, cellSize, 5);
            }
        }

        // Draw blocks
        for (Block block : blocks) {
            block.draw();
        }

        // Draw timer
        fill(0);
        textAlign(PConstants.RIGHT, PConstants.TOP);
        textSize(20);
        text(String.format("Time: %.1f", (millis() - startTime) / 1000.0f), width - 20, 20);

        // Draw game over
        if (gameOver) {
            fill(0, 0, 0, 128);
            rect(0, 0, width, height);
            fill(255);
            textAlign(PConstants.CENTER, PConstants.CENTER);
            textSize(40);
            text("GAME OVER", width/2, height/2);
            textSize(20);
            text("Press 'r' to restart", width/2, height/2 + 40);
        }
    }

    public void keyPressed() {
        if (gameOver) {
            if (key == 'r' || key == 'R') {
                resetGame();
            }
            return;
        }

        boolean moved = false;
        switch (keyCode) {
            case UP:
                moved = moveBlocks(0, -1);
                break;
            case DOWN:
                moved = moveBlocks(0, 1);
                break;
            case LEFT:
                moved = moveBlocks(-1, 0);
                break;
            case RIGHT:
                moved = moveBlocks(1, 0);
                break;
        }

        if (moved) {
            addRandomBlock();
            if (!canMove()) {
                gameOver = true;
            }
        }
    }

    public void mousePressed() {
        if (gameOver) return;

        int col = (int)((mouseX - CELL_PADDING) / (cellSize + CELL_PADDING));
        int row = (int)((mouseY - CELL_PADDING) / (cellSize + CELL_PADDING));

        if (col >= 0 && col < gridSize && row >= 0 && row < gridSize) {
            if (grid[row][col] == 0) {
                int value = random.nextBoolean() ? 2 : 4;
                addBlock(row, col, value);
            }
        }
    }

    private boolean moveBlocks(int dx, int dy) {
        boolean moved = false;
        boolean[][] merged = new boolean[gridSize][gridSize];

        // Sort blocks based on movement direction
        blocks.sort((a, b) -> {
            if (dx != 0) {
                return dx > 0 ? b.col - a.col : a.col - b.col;
            } else {
                return dy > 0 ? b.row - a.row : a.row - b.row;
            }
        });

        for (Block block : blocks) {
            int newRow = block.row;
            int newCol = block.col;
            boolean canMove = true;

            while (canMove) {
                int nextRow = newRow + dy;
                int nextCol = newCol + dx;

                if (nextRow < 0 || nextRow >= gridSize || nextCol < 0 || nextCol >= gridSize) {
                    break;
                }

                if (grid[nextRow][nextCol] == 0) {
                    grid[newRow][newCol] = 0;
                    grid[nextRow][nextCol] = block.value;
                    newRow = nextRow;
                    newCol = nextCol;
                    moved = true;
                } else if (grid[nextRow][nextCol] == block.value && !merged[nextRow][nextCol]) {
                    grid[newRow][newCol] = 0;
                    grid[nextRow][nextCol] *= 2;
                    merged[nextRow][nextCol] = true;
                    moved = true;
                    break;
                } else {
                    break;
                }
            }

            if (newRow != block.row || newCol != block.col) {
                block.row = newRow;
                block.col = newCol;
            }
        }

        return moved;
    }

    private void addRandomBlock() {
        ArrayList<int[]> emptyCells = new ArrayList<>();
        for (int i = 0; i < gridSize; i++) {
            for (int j = 0; j < gridSize; j++) {
                if (grid[i][j] == 0) {
                    emptyCells.add(new int[]{i, j});
                }
            }
        }

        if (!emptyCells.isEmpty()) {
            int[] cell = emptyCells.get(random.nextInt(emptyCells.size()));
            int value = random.nextBoolean() ? 2 : 4;
            addBlock(cell[0], cell[1], value);
        }
    }

    private void addBlock(int row, int col, int value) {
        grid[row][col] = value;
        blocks.add(new Block(row, col, value));
    }

    private boolean canMove() {
        // Check for empty cells
        for (int i = 0; i < gridSize; i++) {
            for (int j = 0; j < gridSize; j++) {
                if (grid[i][j] == 0) return true;
            }
        }

        // Check for adjacent same values
        for (int i = 0; i < gridSize; i++) {
            for (int j = 0; j < gridSize; j++) {
                int value = grid[i][j];
                if ((i < gridSize - 1 && grid[i + 1][j] == value) ||
                    (j < gridSize - 1 && grid[i][j + 1] == value)) {
                    return true;
                }
            }
        }
        return false;
    }

    private void resetGame() {
        grid = new int[gridSize][gridSize];
        blocks.clear();
        gameOver = false;
        startTime = millis();
        addRandomBlock();
        addRandomBlock();
    }

    private class Block {
        int row, col, value;

        Block(int row, int col, int value) {
            this.row = row;
            this.col = col;
            this.value = value;
        }

        void draw() {
            float x = CELL_PADDING + col * (cellSize + CELL_PADDING);
            float y = CELL_PADDING + row * (cellSize + CELL_PADDING);
            
            int colorIndex = (int)(Math.log(value) / Math.log(2)) - 1;
            if (colorIndex < 0) colorIndex = 0;
            if (colorIndex >= COLORS.length) colorIndex = COLORS.length - 1;
            
            fill(COLORS[colorIndex]);
            rect(x, y, cellSize, cellSize, 5);
            
            fill(value <= 4 ? 119 : 255);
            textAlign(PConstants.CENTER, PConstants.CENTER);
            textSize(cellSize / 3);
            text(String.valueOf(value), x + cellSize/2, y + cellSize/2);
        }
    }
}
